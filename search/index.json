[{"content":"前言\r什麼是 RPC（英語：Remote Procedure Call）？ RPC是分散式計算中，一個用於遠端程序呼叫的電腦通訊協定。 該協定允許執行於一台電腦的程式呼叫另一個位址空間（通常為一個開放網路的一台電腦）的子程式，而程式設計師就像呼叫本地程式一樣，無需額外地為這個互動作用編程（無需關注細節）。 RPC是一種伺服器-客戶端（Client/Server）模式，經典實現是一個通過傳送請求-接受回應進行資訊互動的系統。\n什麼是 gRPC？ gRPC 是由雲端原生運算基金會管理的開放原始碼 API 架構和系統，最初由Google建立並提出的。 gRPC以 Remote Procedure Call (RPC) 模型為基礎是一種特定實作，可搭配C#、python、Go等等(支援語言)，其http協定是\u0026quot;使用http/2\u0026quot;。 gRPC 訊息是使用 Protobuf (一種有效率的二進位訊息格式) 進行序列化，又其使用 \u0026ldquo;Protocol Bufferes作為介面定義語言(interface definition language, IDL)\u0026quot;，因此在開發上可以更快速的在不同的語言、服務上互動。 有別於一般open api使用url、http methods、參數等在client與server間互動，gRPC的IDL則更為直觀明確，\u0026ldquo;client與server端皆須使用同一份 .proto 檔案作為介面\u0026rdquo;。\n環境\rPython: 3.10\nOS: Windows 11\nPackage:\npip install grpcio pip install grpcio-tools 步驟\r建立檔案 helloworld.proto ProtoBuf 語法類似 C++ 語言， 相關規範\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Protocol Buffers 有 v2 和 v3 的版本，基本上都會使用較新的 v3 版本， syntax = \u0026#34;proto3\u0026#34;; // service代表RPC介面 // The greeting service definition. service Greeter { // Sends a greeting rpc SayHello (HelloRequest) returns (HelloReply) {} // Sends another greeting rpc SayHelloAgain (HelloRequest) returns (HelloReply) {} } // message是代表資料結構（裡面可以包含不同類型的成員變數，包括字串、數字、數組、字典…） // 變數後面的數字是代表進行二進制編碼時候，用來「識別（identify）」欄位 // 識別號碼在 [1 - 15] 時，佔用 1 個 byte，而 [16 - 2047] 則佔用 2 個 byte。原則上，你應該將你常用的欄位放在 [1 - 15] 的識別號碼內。 // The request message containing the user\u0026#39;s name. message HelloRequest { string name = 1; } // The response message containing the greetings message HelloReply { string message = 1; } 編譯 helloworld.proto 1 2 3 # 將資料夾中所有 .proto 進行編輯 python -m grpc_tools.protoc --python_out=. --grpc_python_out=. -I .\\ *.proto # 產生 helloworld_pb2_grpc.py helloworld_pb2.py 建立或取得greeter_client.py範本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from __future__ import print_function import logging import grpc import helloworld_pb2 import helloworld_pb2_grpc def run(): print(\u0026#34;Will try to greet world ...\u0026#34;) with grpc.insecure_channel(\u0026#39;localhost:50051\u0026#39;) as channel: stub = helloworld_pb2_grpc.GreeterStub(channel) response = stub.SayHello(helloworld_pb2.HelloRequest(name=\u0026#39;you\u0026#39;)) print(\u0026#34;Greeter client received: \u0026#34; + response.message) response = stub.SayHelloAgain(helloworld_pb2.HelloRequest(name=\u0026#39;you\u0026#39;)) print(\u0026#34;Greeter client received: \u0026#34; + response.message) if __name__ == \u0026#34;__main__\u0026#34;: logging.basicConfig() run() 建立或取得greeter_server.py範本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from concurrent import futures import logging import grpc import helloworld_pb2 import helloworld_pb2_grpc class Greeter(helloworld_pb2_grpc.GreeterServicer): def SayHello(self, request, context): return helloworld_pb2.HelloReply(message=\u0026#34;Hello, %s!\u0026#34; % request.name) def SayHelloAgain(self, request, context): return helloworld_pb2.HelloReply(message=f\u0026#34;Hello again, {request.name}!\u0026#34;) def serve(): port = \u0026#34;50051\u0026#34; server = grpc.server(futures.ThreadPoolExecutor(max_workers=10)) helloworld_pb2_grpc.add_GreeterServicer_to_server(Greeter(), server) server.add_insecure_port(\u0026#34;[::]:\u0026#34; + port) server.start() print(\u0026#34;Server started, listening on \u0026#34; + port) server.wait_for_termination() if __name__ == \u0026#34;__main__\u0026#34;: logging.basicConfig() serve() 執行 1 2 3 4 5 6 python .\\greeter_server.py # Server started, listening on 50051 python .\\greeter_client.py # Greeter client received: Hello, you! # Greeter client received: Hello again, you! 參考資料\r遠端程序呼叫 gRPC Python Quick start 初識 Protocol Buffers ","date":"2024-09-18T15:47:27+08:00","permalink":"https://Lin16.github.io/p/grpc/","title":"gRPC"},{"content":"前言\r雖然現在開發和測試甚至小型服務很常使用Docker處理，但是還是會有需要安裝的時候。 因此整理一下手邊安裝過程筆記，久久安裝一次時就可以使用。\n環境\rOS: Ubuntu 24.04.1 LTS\n步驟\r註: 如果遇到沒寫到的，原則上直接按下一步即可。\n語言 使用預設 English\nKeyboard configuration 使用預設\n選擇安裝 Ubuntu Server (minimized)\n網路設定，預設使用DHCP，如果有需要可已設定固定IP，範例如下\n1 2 3 4 Subnet: 192.168.1.0/24 Address: 192.168.1.101 Gateway: 192.168.1.1 Name servers: 8.8.8.8 Configure proxy 不輸入\nConfigure Unbuntu archive mirror 使用預設\nGuided storage configuration 使用預設\nStorage configuration 使用預設\nProfile setup，設定主機名稱及帳號密碼等\n啟用 Install OpenSSH server(不用就不啟用)\n參考資料\rGet Ubuntu Server ","date":"2024-09-16T12:36:25+08:00","permalink":"https://Lin16.github.io/p/install/","title":"[ubuntu Server] 最小化安裝 install minimized"},{"content":"前言\rHugo本身有「最後更新」功能，紀錄一下啟用步驟\n步驟\r開啟hugo.yaml並加入以下內容 1 2 3 4 5 6 7 8 9 10 11 12 13 # 利用git記錄的文件修改時間作為真實更新時間 # 傳回與給定頁面的最後一次提交相關的 Git 資訊 enableGitInfo: true frontmatter: lastmod: [\u0026#39;:git\u0026#39;, \u0026#39;lastmod\u0026#39;, \u0026#39;date\u0026#39;, \u0026#39;publishDate\u0026#39;] # 參數說明： # :git：git記錄的文件提交修改時間 # lastmod：文章裡lastmod字段 # :fileModTime：文件修改時間，會受自動部署的影響 # :defalut：預設時間 # 更多參數 # https://gohugo.io/content-management/front-matter/ 將「最後更新」位置變更 1 2 3 4 5 6 7 8 9 10 11 12 # 原本位置 # themes\\hugo-theme-stack\\layouts\\partials\\article\\components\\footer.html {{- if ne .Lastmod .Date -}} \u0026lt;section class=\u0026#34;article-lastmod\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;span\u0026gt; {{ T \u0026#34;article.lastUpdatedOn\u0026#34; }} {{ .Lastmod | time.Format ( or .Site.Params.dateFormat.lastUpdated \u0026#34;Jan 02, 2006 15:04 MST\u0026#34; ) }} \u0026lt;/span\u0026gt; \u0026lt;/section\u0026gt; {{- end -}} # 剪下貼至想要的位置 # themes\\hugo-theme-stack\\layouts\\partials\\article\\components\\details.html 參考資料\rHugo Stack 主题添加「最后修改于」 ","date":"2024-09-13T13:12:22+08:00","permalink":"https://Lin16.github.io/p/last-update-time/","title":"[Hugo]在文章中顯示「最後更新時間」"},{"content":"需求\r有一天有大量內部臨時啟用系統需要偵測服務狀態，由於數量太多因此考量是否能由程式代勞。\n臨時系統有提供API來查詢系統狀況且回傳格式為JSON，那就寫一段PowerShell來試試。\n說明\r首先透過Invoke-WebRequest可以取得系統狀況。 接者使用ConvertFrom-Json轉為Json，後續就可以判斷服務當前狀況。\n範例程式如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #num 輸入機器數量 function CheckService($num) { # 迴圈處理 for($i=1;$i -le ($num);$i++) { Write-Host \u0026#34;編號:$($i)開始\u0026#34; # 準備網址 $uri= \u0026#34;http:/XXX.XXX.XXX.\u0026#34; + $i # Check $response = Invoke-WebRequest -Uri $uri $jsonObj = ConvertFrom-Json $([String]::new($response.Content)) if($jsonObj.status -eq \u0026#34;red\u0026#34;){ Write-Host jsonObj.status } Write-Host \u0026#34;----------------------------------------\u0026#34; } Write-Host \u0026#34;Check End\u0026#34; } ","date":"2023-08-11T15:13:06+08:00","permalink":"https://Lin16.github.io/p/monitor-service-status/","title":"透過PowerShell監控服務運行狀態"},{"content":"前言\rThehe stack 原生功能大部分符合我個人期待。 但是有些小地方還是希望微調，這邊就是紀錄調整的過程\n環境\rHugo: hugo_extended_0.117.0_windows-amd64.zip\n說明\r調整網頁佈局(Grid)\r修改位置: hugo-theme-stack/assets/scss/grid.scss 修改項目:\n.left-sidebar \u0026raquo; max-width .right-sidebar \u0026raquo; max-width .extended \u0026raquo; @include respond(xl) 完整程式碼如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 .left-sidebar { order: -3; max-width: var(--left-sidebar-max-width); //max-width: 10%; } .right-sidebar { order: -1; // max-width: var(--right-sidebar-max-width); max-width: 20%; /// Display right sidebar when min-width: lg @include respond(lg) { display: flex; } } \u0026amp;.extended { @include respond(md) { max-width: 1024px; --left-sidebar-max-width: 25%; --right-sidebar-max-width: 30%; } @include respond(lg) { max-width: 1280px; --left-sidebar-max-width: 20%; --right-sidebar-max-width: 30%; } @include respond(xl) { //max-width: 1536px; max-width: 1900px; --left-sidebar-max-width: 15%; --right-sidebar-max-width: 25%; } } 文章底木增加一段固定文字，類似簽名檔\rhugo.yaml，在article 底下新增參數 signatureLine 1 2 3 4 5 6 7 8 9 article: math: false toc: true readingTime: true license: enabled: true default: Licensed under CC BY-NC-SA 4.0 # 新增 signatureLine signatureLine: 如果文章內容有錯誤或是參考聯結有問題..等，還請幫忙告知，謝謝。 前往 layouts\\partials\\article\\components\\content.html，調整如下: 1 2 3 4 5 6 7 \u0026lt;section class=\u0026#34;article-content\u0026#34;\u0026gt; \u0026lt;!-- Refer to https://discourse.gohugo.io/t/responsive-tables-in-markdown/10639/5 --\u0026gt; {{ $wrappedTable := printf \u0026#34;\u0026lt;div class=\\\u0026#34;table-wrapper\\\u0026#34;\u0026gt;${1}\u0026lt;/div\u0026gt;\u0026#34; }} {{ .Content | replaceRE \u0026#34;(\u0026lt;table\u0026gt;(?:.|\\n)+?\u0026lt;/table\u0026gt;)\u0026#34; $wrappedTable | safeHTML }} \u0026lt;!-- 新增這段 --\u0026gt; {{ .Site.Params.article.signatureLine }} \u0026lt;/section\u0026gt; 將註解顏色改成想要的顏色，例如綠色\r1 2 3 4 5 6 7 8 // 檔案位置 // themes\\hugo-theme-stack\\assets\\scss\\partials\\highlight\\common.scss // 修改，以其中一種註解為例 /* CommentSingle */ .chroma .c1 { // color: #75715e; color: #4f8416; } 參考資料\r博客切换到STACK 主题 ","date":"2023-08-10T11:49:11+08:00","permalink":"https://Lin16.github.io/p/theme-stack-adjusted/","title":"Theme Stack 調整紀錄"},{"content":"需求\r將多個list資料合併成一個list\n完整程式碼\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 List\u0026lt;string\u0026gt; list1 = new List\u0026lt;string\u0026gt;() {\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;}; List\u0026lt;string\u0026gt; list2 = new List\u0026lt;string\u0026gt;() {\u0026#34;C\u0026#34;,\u0026#34;D\u0026#34;}; 方法一: var list3 = list1.Concat(list2).ToList(); // Console.WriteLine(list3); // {\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;D\u0026#34;} 方法二: list1.AddRange(list2); // Console.WriteLine(list1); // {\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;D\u0026#34;} ","date":"2023-08-10T11:11:32+08:00","permalink":"https://Lin16.github.io/p/list-combine/","title":"[C#]多個List 資料進行合併(combine)"},{"content":"前言\r用Markdown寫文件已經成為工作的一部分了，手邊累積零散的筆記也見季都改由Markdown紀錄。 因此弄一個支援Markdown的部落格想法越來越強烈，經過一番研究後決定選Hugo + Github Pages。\n環境\rOS: Windows 11 git: 2.40 Hugo: hugo_extended_0.134.2_windows-amd64 步驟\r部屬Hugo 網站\r前往Hugo下載 hugo.exe 的 ZIP 檔 或是Hugo GitHub Releases頁面。 可以選擇一般版本的 Hugo 或是 Hugo Extended，兩個版本的差異在於有沒有內建支援SCSS、SASS。\n註: 建議直接選擇 Extended 版本，因為有許多的模板、主題都會用到 SCSS 或 SASS，可以省得之後再自己手動安裝的麻煩。\nex: hugo_extended_0.134.2_windows-amd64 將ZIP檔解壓縮後取得「hugo.exe」，接者放置到準備的位置，例如:C:\\Hugo\\bin\\ 前往環境變數並於Path新稱值「C:\\Hugo\\bin\\」 開啟PowerShell並輸入以下指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 檢查Hugo版本以及環境變數是否正設定 hugo version # 建立網站，這邊命名為 blog hugo new site blog # 進入資料夾 cd blog # 下載要使用的主題，ex: hugo-theme-stack # 註:預設是沒有主題(Themes)，需要自己載，[官網Themes](https://themes.gohugo.io/)有很多可以選 git clone https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack # option: 複製並採用 hugo-theme-stack範例中的hugo.yaml檔案及設定，取代hugo.toml # option: 複製 archetypes的檔案 # option: 複製既有文章 # option: 建立第一個文章 hugo new post\\python\\install\\install.md #啟動網站，-D 顯示草稿 hugo server -D 開啟瀏覽器，預設網址http://localhost:1313/，順利的話可以看到網站 上傳至GitHub\r註冊GitHub帳號 建立一個Repository Repository name: 填入「github-username.github.io」 ，注意github-username是要替換成GitHub帳號的名稱 開啟PowerShell並輸入以下指令 1 2 3 4 5 6 7 8 9 10 cd blog # 建置網站，完成檔檔案會放置於「public」資料夾 hugo --cleanDestinationDir cd public git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin https://github.com/github-username/github-username.github.io.git git push -u origin main 開啟瀏覽器，訪問http://github-username.github.io.git，順利的話可以看到網站 參考資料\r用 Markdown 寫技術文件 - 編輯工具與平台選擇 Hugo 貼身打造個人部落格 ","date":"2023-08-10T00:04:32+08:00","permalink":"https://Lin16.github.io/p/hugo-on-github-pages/","title":"部屬Hugo到Github Pages"}]